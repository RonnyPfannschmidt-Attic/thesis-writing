\chapter{Zielspezifikation ( 5 \%)}
\label{chap:target}
Wie das letzte Kapitel gezeigt hat,
bringen bisherige Systeme diverse Probleme mit sich.
Da diese nicht oder nur schwer innerhalb dieser Systeme lösbar sind,
soll ein neues System geschaffen werden.

Dieses Kapitel soll die entsprechenden Ziele
qualitativ und quantitativ festlegen.

% tests in sektionen mit angeben

% zeitanforderungen ?!

% funktional, tests, szstemanforderunge? bessereer name
% abgrenzungen



\section{Systemanforderungen}

Die Systemanforderungen legen funktionale Eigenschaften der Software auf System-ebene fest.
Dabei werden 3 Punkte als wichtig erachtet.


\begin{description}

\dhitem[S1]
  Das System darf sich nicht vom Absturz/Fehlerfall \\
  einzelner Komponenten stören lassen. Jederzeit muss \\
  es möglich sein, Teile des Systems hart zu beenden \\
  oder die Struktur des Systems zu verändern.

\dhitem[S2]
  Alle anfallenden Längerfristig verfügbaren Daten \\
  mittels einer Standard-Schnittstelle für \\
  Datenbankzugriff abfragbar/verwendbar sein.

\dhitem[S3]
  Das System soll offen für Erweiterungen stehen, \\
  und soweit möglich Erweiterbarkeit aktiv unterstützen.
\end{description}


\section{Funktionale Anforderungen und UseCases}
% kann/soll kriterien

Um ein modernes und erweiterbares CI-System zu schaffen,
müssen zuerst die Kernfunktionen festgelegt werden.
Anschließend kann auf dieser Basis
eine Plattform für Erweiterungen geschaffen werden.
Dabei ist schon im Kern das bereits Angesprochene Problem
der Matrix-Builds zu beachten.

Anschließend können auf dieser Basis nützliche weiterführende Funktionen
sowie die gewünschten Erweiterungen geschaffen werden.


\subsection{Kernfunktionen}

Die Kernfunktionen bilden das absolute Minimum an Funktionen.
Jede von ihnen ist unabdingbar.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\textwidth]{imageinput/use-case-muss.png}
  \caption{\"Ubersicht Use-Cases - Kern}
  \label{fig:use-case-muss}
\end{figure}

Wie in Abbildung~\ref{fig:use-case-muss} gut zu erkennen,
stellt sich der Absolute Kern eines CI-Systeme aus relativ wenigen Funktionalitäten zusammen.

Die erste notwendige Funktion stellt die Verwaltung von Projekten \deffeat{projekt-verwalten}.
Sind diese dann angelegt, kann man damit beginnen, Aufträge abzusetzen \deffeat{auftrag-absetzen}.
Ist ein Auftrag abgesetzt, so muss seine Richtigkeit sichergestellt werden \deffeat{auftrag-validieren},
danach kann er für die Bearbeitung \deffeat{auftrag-vorbereiten} vorbereitet werden.

Nach dem der Auftrag an sich vorbereitet ist, müssen entsprechend der Build-Matrix \deffeat{auftrag-matrix}
Arbeitspakete generiert werden \deffeat{arbeitspacket-generieren}.
Diese Arbeitspakete werden anschließend verteilt \deffeat{arbeitspacket-verteilen} und abgearbeitet \deffeat{arbeitspacket-abarbeiten}.

Das Abarbeiten der Arbeitspakete sollte in Schritten erfolgen \deffeat{arbeitspackete-schritte},
wobei die grundlegende Art von Arbeitsschritt das Ausführen eines Prozesses \deffeat{arbeitsschritt-prozess} ist.


\subsection{Weiterführende Funktionen}

Nach dem Umsetzung des funktionalen Kerns als Basis,
k\"onnen nun weiterf\"uhrende Funktionen angelagert werden.
Diese sind nicht zwingend notwendig, tragen jedoch erheblich dazu bei,
informierte Entscheidungen \"uber den Zustand eines Projektes in Integration zu treffen.

\subsubsection{Datensammlung}

Zun\"achst einmal gilt es Datensammlung beim Ablauf eines Arbeitsschritts zu betrachten.
\"Ublicherweise muss zumindest STDOUT/STDERR schon zur Laufzeit festgehalten \deffeat{arbeisschritt-stdio} werden.
Weiterhin besteht auch Interesse an statistisch auswertbaren Daten
wie z.B. den Speicher-verbrauch \deffeat{arbeitsschritt-stats}.

Auch nach dem Ausf\"uhren eines Arbeitsschritts fallen interessante Daten an.
Oftmals sorgt zumindest einer der Arbeitsschritte für das Generieren eines Ausführbaren Programms.
Dieses sollte sp\"ater auch zur Verf\"ugung gestellt werden \deffeat{arbeitsschritt-artefakt}.
Weiterhin finden sich Test-Resultate in diversen Standardformaten \deffeat{arbeitsschritt-resultate},
wie z.B. JunitXML.

\subsubsection{Arten Arbeitsschritte}

Auch bei den Arten der Arbeitsschritte gibt es f\"r gew\"ohnlich mehrere M\"oglichkeiten (siehe Kapitel~\ref{chap:ist-analyse}).
Neben den gewohnten Prozess-schritten (\reffeat{arbeitsschritt-prozess}) sind weitere Arten \"ublich.
Interaktion mit dem Quellcodemanagement \deffeat{arbeitsschritt-scm}, sowie
Schritte implementiert in einer Skript-Sprache \deffeat{arbeitsschritt-script},
stellen weiterf\"uhrende Hilfen dar.

\subsubsection{Verteilung von Arbeitspacketen}

Um \"uberhaupt bis zu den Arbeitsschritten zu kommen,
ist es notwendig, Arbeitspakete zu verteilen \deffeat{arbeitspackete-verteilen}.
Dies soll ein verteilter Prozess sein \deffeat{arbeitspackete-autonome-verteilung},
bei dem die Slaves/Arbeiter aktiv mitwirken k\"onnen.
Eine denkbare Erweiterung w\"are die Möglichkeit, das Slaves/Arbeiter
die Arbeitspakete mittels kategorischer Filter auswählen \deffeat{arbeitspackete-verteilung-selektiv}.
Beispiele f\"ur diese w\"aren z.b. Plattform oder Betriebsumgebung.

\subsubsection{Auftragseingang und Vorbereitung}

%XXX: web hook gosar

Der Auftragseingang kann sich vielseitig gestalten.
Moderne Systeme unterstützen eine Vielzahl von Medien \deffeat{auftrag-eingang-medien},
wie z.b. Email, Web-Hooks, Web-Formulare oder Zeitgesteuerte Systeme.

W\"unschenswerte Erweiterungen, welche nicht von existierenden Systemen unterst\"utzt werden,
sind die Anreicherung eines Auftrages um eigene Daten/\"Anderungen.
Besonders hilfreich erscheint hierbei das sogenannte Workdir-diff \deffeat{auftrag-eingang-diff},
welches die aktuellen \"Anderungen eines Entwicklers darstellen.
Dies macht sie besonders n\"utzlich f\"ur den laufenden Entwicklungsprozess.

\subsubsection{Resultatanalyse}

Analyse von Resultaten ist ein vielseitiges Thema,
welches vorwiegend Aufgabe der Erweiterungen sein soll.

In der grundlegenden eingebauten Ausf\"uhrung soll zumindest der Erfolg oder Misserfolg
von Auftr\"agen, Arbeitspaketen und Arbeitsschritten feststellbar sein \deffeat{einfache-resultate}.

Die weitergehende Analyse von Ergebnissen soll mittels Erweiterungen behandelt werden.

\subsection{Exemplarische Erweiterungen}

Um die Erweiterbarkeit des Systems aufzuzeigen,
sollen 2 exemplarische Erweiterungen betrachtet werden.
Diese werden hier nur Grob umrandet und dann Sp\"ater in der Analyse genauer spezifiziert.

Dir erste Erweiterung betrachtet vergleichende Analysen von Testergebnisen \deffeat{ext-testing}.
Dabei sollen Entwickler in die Lage versetzt werden,
dass Fehler-verhalten eines Programms in verschiedenen Konfigurationen und Auftr\"agen zu vergleichen.
Dies dient zur Vereinfachung der Fehleranalyse.

Die zweite Entwicklung betrachtet ein gänzlich anderes Thema.
Dabei soll das Verhalten einer Version eines Programms
in sehr vielen Kombinationen verst\"andlich gemacht werden\deffeat{ext-analysis}.
Dies soll die Flexibilit\"at des Systems zeigen und
Ideen f\"ur neue Ans\"atze und Werkzeuge bei der Qualit\"atssicherung liefern.


%XXX eventuell spaeter
%\subsection{Vorgaben f. Entwiclungsumgebung}?
%- testen notwendig
%- das system selber ci unterziehen

% %- regeln


\section{Testkriterien}


\subsection{Unit Tests}

Unit-Tests werden verwendet um die kleinsten Komponenten des Systems zu testen.
Durch ihre starke Koppelung an Implementation und Entwurf,
sind die w\"ahrend der Kriterien-Findung noch nicht n\"aher bestimmbar.

Sie ergeben sich zum Teil im Entwurf und vorwiegend in
der nachfolgenden Implementation.

\subsection{Funktionale Tests}

Funktionale Tests testen einzelne funktionale Komponenten des Systems.
Daher entsprechen sie Grob den funktionalen Anforderungen und Use-cases.
%XXX: mehr text

\subsection{Systemtests}

Systemtests testen Kombinationen von funktionalen Komponenten sowie das Komplettsystem.
Im Rahmen dieser Arbeit werden 3 Systemtests definiert.


\begin{description}
  \dhitem[Komponentendurchlauf]
    soll anhand des Ausführens der einzelnen funktionalen Komponenten aufzeigen,
    ob das Zusammenspiel der Komponenten grunds\"atzlich funktioniert
  \dhitem[Komplettstystem]
    soll das komplette CI-System auf einer Testdatenbank starten
    und seine Funktion sicherstellen
  \dhitem[Beispiel Datenanalyse]
    soll die Funktion der Beispielerweiterung f\"ur Datenanalyse sicherstellen
\end{description}

\subsection{Manuelle Tests}

Die manuellen Tests werden alle Tests umfassen,
deren Umsetzung als automatisches Programm erfahrungsgemäß zeitaufwendig,
fehleranf\"allig und/oder umfangreich sind.

\begin{description}
  \dhitem[zeitliches Verhalten]
    Beobachtung und Analyse des Zeitverhaltens \\
    bei wachsender Datenmenge und Auftragsgröße
  \dhitem[Race-Conditions]
    Beobachtung und Analyse trivialer Race-Conditions \\
    bei wachsender Nebenl\"aufigkeit
  \dhitem[Verhalten bei Systemfehler]
    \"Uberpr\"ufung des Verhaltens beim Absturz von Teilkomponenten
  \dhitem[Grosse Datenanalyse]
    Testen der exemplarischen Erweiterungen mit Datenmengen und Aufgaben \\
    die den Rahmen eines automatischen Tests sprengen
\end{description}


\section{Abgrenzung}

In dieser Arbeit soll nur der prototypische Kern eins CI-Systems,
sowie exemplarische Erweiterungen, geschaffen werden.
Somit sind viele Themen, welche für ein produktiv eingesetztes CI-System notwendig
sind, nicht weiter zu betrachten.
Benutzer und ihre Rechte sollen nicht betrachtet werden,
Authentifikation und Authorisation sind weitreichende Themen-gebiete
die sorgf\"altigst betrachtet werden m\"ussten,
dies ist neben der Hauptaufgabe nicht im zeitlichen Rahmen unterzubringen.
Außerdem wird kein Wert auf die Benutzeroberfläche gelegt.
intuitive Benutzerinteraktion ist ein \"uberaus umfangreiches Thema.
Dabei sind auch weiterführende Interaktionen,
wie z.B. Konfiguration der Replikation ausgeschlossen.


\section{Zusammenfassung}

%XXX: more text

Im wesentlichen soll der Kern des CI-Systems als Protoyp geschaffen werden.
Anschließend sollen weitere Funktionen sowie exemplarische Erweiterungen
auf dieser Basis geschaffen werden.
L\"osungskonzepte f\"ur die einzelnen Komponenten sollen vorgestellt werden,
um anschließend ihre Eigenschaften zu betrachten

Fokus sind dabei Interaktionen mit der Datenbank und Datenoperationen.
Semantik des Systems und Konsistenz-verhalten bei Datenbankpartitionierung
sollen betrachtet werden. Erweiterungen zur Datenanalyse sollen ebenfalls nur auf technischer Ebene behandelt werden.

Themen wie Benutzerschnittstellen, Rechteverwaltung und Details
von visueller Komponentenintegration werden dabei nicht betrachtet.
Ziel dieser Arbeit ist die Betrachtung der Kernfunktionen und Erweiterungen auf Datenbank-ebene.

% zusammenfassung 
%   - im wesentlichen soll \ldots. prototypisch & exemplarisch
%   anhand .. soll ein loesungskonz vorgestellt werden
