\chapter{Implementation ( 15 \% ) }

Dieses Kapitel beschreibt die Implementation des Systems.
Dabei wird zuerst auf Wahl der Werkzeuge eingegangen,
Anschließend wird die Struktur Beschrieben.
Danach werden Primitiven vorgestellt, welche die Implementatio nder Komponenten vereinfachen.
Schließlich werden Besonderheiten bei der Implementation einiger Komponenten vorgestellt.
Zum Schluss werden die exemplarischen Erweiterungen vorgestellt.

\section{Werkzeuge}
\subsection{Datenbank}

Das Kriterium der \textbf{Master-Master Replikation}
schränkte die Auswahl der verwendbaren Datenbanksysteme bereits stark ein.

In die nähere Betrachtung kommen CouchDB (dokumentorientiert)
und PostgreSQL (relational).
Beide Systeme besitzen Werkzeuge f\"ur Master-Master Replikation
und primitiven für Notifikationen.

%XXX: cites
Andere Systeme wie Mysql (relational), Mongodb(dokumentorientiert)
und  Neo4J (graph) scheiden aus, weil zu ihrem Funktionsumfang
nur die Master-Slave Replikation geh\"ort.
Das System Riak wurde verworfen, da es \"Anderungs-notifikationen
nicht unterstützte und in einem kurzen Vergleich
die Anfragen langsamer beantwortete.

Im Kurzvergleich von PostgreSQL mit CouchDB,
ging CouchDB als  hervor.
Im Test mussten bei Couchdb zwar Abstriche im Bereich Performance gemacht werden,
jedoch stellte sich heraus, das die \"Anderungsnotifikationen von Couchdb detaillierter sind.
Außerdem erscheint der Prozess der Replikation in CouchDB
als fehlertoleranter und einfacher.

% \cite
W\"ahrend in PostgreSQL die Mitteilungen einfach nur eine Nachricht sind,
welche mitteilt, dass etwas geändert wurde (aber nicht was)
% \cite couchdb:changestream}
so beinhalten die Mitteilungen von CouchDB, genaue Informationen
\"uber das ge\"anderte Objekt, eventuelle Datenbankkonflikte
und auf Wunsch sogar das Objekt selbst.

%XXX: more
 
\subsection{Programmiersprachen}

Es wurden 2 Programmiersprachen Ausgew\"ahlt.
Zum einen Python, wegen seiner Bibliotheken und
zum anderen Javascript, da es die Datenbankinterne Sprache von Couchdb ist.

\begin{table}[ht]
\centering
\begin{tabular}{l|c|c}
                            & \textbf{Python} & \textbf{Javascript} \\
    \hline
    Datenbankintern         & nein            & ja \\
    Prozesskontrolle        & integriert      & extern, rudimentär \\
    SCM Api                 & verfügbar       & nicht verfügbar \\
    CouchDB Client          & verfügbar       & verfügbar \\
\end{tabular}
\caption{Überblick über Features und Bibliotheken der Sprachen}
\label{tab:python-vs-js}
\end{table}

Ein besonderes Problem mit Javascript ist,
dass es Datenbankintern Bibliotheken, die Datenbank-extern sind,
nicht oder nur in limitierter Form verwenden kann.
Die Laufzeitumgebung weißt große Unterschiede
zwischen Datenbank-interner und Datenbank-externer Verwendung auf.

Weiterhin konnten wie in \Cref{tab:python-vs-js} aufgezeigt,
für einige benötigte Bibliotheken keine
oder nur unzureichende Implementationen gefunden werden.
Somit ist Javascript für die Implementation der Komponenten
nur sehr bedingt geeignet.

Python hingegen hat Bibliotheken für alle notwendigen Grundfunktionen
und hat somit alle Voraussetzungen,
um die Implementation der Komponenten zu stützen.

\subsection{Bibliotheken}

Diese Sektion stellt die genutzten Bibliotheken vor.

\subsubsection{Datenbank Interaktion}

Zur Interaktion mit CouchDB wurde die Bibliothek ``couchdbkit"" \cite{couchdbkit:website} verwendet.
Sie stellte als einzige alle Funktionen der HTTP-Api von CouchDB zur Verfügung.
%XXX cites?
Andere Bibliotheken sind python-couchdb (kein Support fuer Änderungsmitteilungen)
und Paisley (sehr Unvollständig)

\subsubsection{SCM Interaktion}

Für die Interaktion mit der Versions-Kontrolle wurde die Bibliothek anyvc \cite{anyvc:website} verwendet.
Sie ist eine von 2 Python Bibliotheken für den Zugriff auf SCM,
und als einzige in der Lage mit einem Arbeitsverzeichniss zu interagieren.

\subsection{Weitere Werkzeuge}

\subsubsection{Testwerkzeuge}

Zum Testen wird das Test Framework py.test \cite{pytest:website} verwendet.
Es das einzige Test Framework für Python,
welches neben Werkzeugen für UnitTests auch Tools für
Funktionale und Akzeptanz Tests mitbringt.

Mit der Erweiterung ``pytest-couchdbkit"" \cite{pytest:couchdbkit} ist es Bereits
bestens für das Testen von Applikationen und einzelnen Funktionen,
welche CouchDB verwenden, geeignet.
Außerdem basiert ``pytest-couchdbkit"" auch auf der Bibliothek ``couchdbkit"",
und ist damit Bestens geeignet um die Basis für den Testprozess zu bilden.

\subsubsection{Datenbank Management}

Zum Management der Datenbank an sich wurde die integrierte Administrationsschnittstelle Futon verwendet \cite{couchdb:futon}.
Sie bietet einfache Schnittstellen für die Verwaltung von Datenbanken sowie der Replikation.

Um Datenbankinterne Programme zu verwalten,
wurde das Werkzeug ``couchdb-compose"" \cite{couchdb:compose} geschaffen.
Die Umsetzung dieses Werkzeugs ist nicht als Teil dieser Arbeit zu betrachten.
Notwendig wurde es, da existierenden Werkzeugen wie ``Kanso"" und ``couchapp""
keine Möglichkeit boten, um direkte Kontrolle über den Aufbau und die Struktur 
einer CouchDB Applikation zu üben.

\subsubsection{Javascript Bibliotheken}

Um einige wiederkehrende Aufgaben in Javascript zu vereinfachen,
wurde die Bibliothek underscore verwendet. \cite{javascript:underscore}.
Sie bietet diverse funktionale Werkzeuge um das schreiben
von Datenbank-internen Filtern und Views zu erleichtern.


\section{Projektstruktur}
\subsection{Überblick}

Die Grundlegende Projekt-struktur beinhaltet einige Hauptverzeichnisse.
Der Codename des Projektes ist dabei ``Juggler''.


\begin{description}
    \item[bin] beinhaltet die Skripts um einzelne Komponenten zu starten
    \item[tool] beinhaltet Werkzeuge um mit der Datenbank des Prototyp zu interagieren
    \item[juggler] beinhaltet die Implementation der Komponenten in Python
    \item[composeapp] beinhaltet die couchdb-compose Applikation
    \item[testing] beinhaltet die automatischen Tests
    \item[example\_data] beinhaltet Beispiel-Datensätze im YAML Format
\end{description}

\subsection{Scripte und Werkzeuge}
Die Skripts und Werkzeuge haben verschiedene Aufgaben und Aufruf-formen,
diese werden hier beschrieben dabei werden Parameter in eckigen Klammern angegeben.
Der Parameter namens \textbf{db} gibt dabei entweder einen kompletten Namen einer  Datenbank an oder den Namen einer lokalen Datenbank an.

\begin{description}
    \item[bin/slave.py] [db] [name] simple \hfill \\
        Started einen Slave/Worker Prozess
    \item[bin/master.py] [db] \hfill \\
        Startet den Master Prozess - es darf nur einen geben und das System testet nicht, ob bereits einer aktiv ist.
    \item[tool/put.py] [db] [item] / [db] [item] --newid \hfill \\
        Überträgt den Inhalt der Datei namens \textit{item} zur Datenbank,
        ist das flag \textit{--newid} gesetzt, so wird eine neue Objekt ID erzwungen
    \item[tool/example-reset-db.sh] \hfill \\
        Shell Skript, um die Datenbank für die manuellen Tests vorzubereiten.
        Es verwendet immer die lokale Datenbank namens ``juggler''
    \item[tool/clean\_standing.py] [db]\hfill \\
        Setzt unterbrochene Arbeitspakete auf den Ursprungs-zustand zurück.
        Dies ist notwendig, da der Prototyp den Status interrupted für ein Arbeitspaket nicht unterstützt.
\end{description}

\subsection{Python Implementation}

Die Python Implementation besteht aus einigen wichtigen Dateien im Ordner namesn juggler.

Einsprungpunkte sind die Dateien ``simple\_master.py' und ``simple\_slave.py''.
Sie beinhalten die Implementationen der Management und Arbeiter Komponenten.

Hinzu kommt die Datei ``service.py'', welche das Grundgerüst für Komponenten enthält.

Folgende Verzeichnisse sind noch wichtig.

\begin{description}
    \dhitem[model] 
        enthält  die Modelklassen,
        welche die Daten aus der Datenbank auf Python Objekte abbilden
    \dhitem[handler] 
        enthält die Einzelteile der Komponenten,
        welche in Kommunikation mit der Datenbank stehen
    \dhitem[process]
        enthält die Implementation der Arbeitsschritte
        und ihrer Ausführungssumgebung
\end{description}



\subsection{Datenbank Indexe}

Die Indexe werden in CouchDB mittels 
eines MapReduce \cite{couchdb:views} Algorithmus umgesetzt,
welcher die Resultate innerhalb der Datenbank speichert.

\begin{description}
    \dhitem[tasks\_of]
        Der ``tasks\_of'' View hat 2 Aufgaben.
        In der Map Phase, erzeugt er eine \hbox{Key zu Value(status), Id} Zuordnung.
        Dabei ist der \textbf{Key} die Id des Auftrages,
        \textbf{Id} ist die Id des Arbeitspaketes
        und \textbf{Value} der Zustand dieses Arbeitspaketes.
        Dies ermöglicht es, einfach herauszufinden
        welche Arbeitspakete zu welchem Auftrag gehören.
        In der Reduce Phase wird schließlich das Set
        der Zustände der Arbeitspakete gebildet,
        besteht dieses ausschließlich aus finalen Zuständen,
        so kann der Auftrag als Abgeschlossen angesehen werden.
    \dhitem[steps\_of]
        Der ``steps\_of'' View hat lediglich die Aufgabe,
        eine Zuordnung von Arbeitsschritten
        zu ihren Arbeitspaketen zu schaffen.
    \dhitem[streams]
        Aufgabe dieses Views ist es,
        festzustellen, welche Datenströme (stdout, stderr)
        eines Arbeitsschritts Daten halten.
    \dhitem[lines]
        Der ``lines'' View dient dem Auffinden der einzelnen Zeilen
        eines Datenstroms. Sie werden nach der Zeilennummer geordnet.
    \dhitem[stm]
        Der ``stm'' view hat mehrere Aufgaben.
        Er dient der Statistischen Analyse und
        erzeugt seine Schlüssel aus der Kombination
        von Typ und Zustand eines Dokumentes.
        Dies ermöglicht es jederzeit festzustellen,
        welche Objekte sich in welchem Zustand befinden.
        In der Reduce Phase wird die Anzahl ermittelt.
        Somit lässt sich jederzeit feststellen,
        welche zustandsbehafteten Dokumente
        sich in welchem Zustand befinden.
%XXX: statret nach testing/eval
\end{description}

\subsection{CouchDB Applikation}

\section{Grundlegende Primitiven}

Die grundlegenden Primitiven unterstützen die Implementation der einzelnen Teile des Prototypen. Die bilden die Basis für eine kompakte und schnell umzusetzende Implementation.

\subsection{listen\_changes}

Die Primitive ``listen\_changes'' dient dazu,
Änderungen der Datenbank den Komponenten der Applikation mitzuteilen.
Dabei kann Typ und weiteren Parametern gefiltert werden.
Somit kann man an eine Folge speziell ausgewählter Änderungen in der Datenbank erhalten.

\subsection{watch\_for}

Die Primitive ``watch\_for'' dient dazu auf eine bestimmte Änderung in der Datenbank zu warten. Dazu setzt sie die ``listen\_changes'' Primitive ein und gibt die erste passende Änderung in der Datenbank zurück.

\subsection{watches\_for - Kontext für Komponenten}

Die Primitive ``watches\_for'' dient dazu einzelne Systemkomponenten
an bestimmte Änderungen der Datenbank zu Knüpfen.
Sie bringt die Zustandsänderungen zum Ausdruck,
bei denen eine Komponente aktiv werden soll.

Außerdem abstrahiert sie die Logik für das Warten auf diese Änderungen
(unter Verwendung der watch\_for primitive)
und ermöglicht es die einzelnen Komponenten direkt mit den Daten Aufzurufen,
auf die sie hätte warten müssen.
Dies ermöglicht es einzelne Komponenten direkt zu testen, ohne dass eine echte Datenbank benötigt wird.

Die Primitive watches\_for umschließt dabei die Funktion, welche die Arbeit verrichtet und schafft durch Komposition eine neue Funktion,
welche basierend auf den übergebenen Parametern die Art und Weise der Vorarbeit entscheidet.

Wird das zu erwartende Objekt nicht mit übergeben, so werden aus den Parametern der Funktion die Parameter für die watches\_for Primitive generiert.
diese wird anschließend verwendet um das zu erwartende Objekt von der Datenbank zu erhalten.



\subsection{run\_callbacks}

Die Primitive ``run\_callbacks'' dient dazu, mehrere Komponenten zu einem Programm
zu kombinieren, sie nimmt die Folge der Änderungen in der Datenbank und
ruft für jede Änderung die passende Komponente auf.

Einzelne Komponenten sind dabei mit der Primitive watches\_for vorbereitet,
die Primitive muss somit nur die Komponenten den Ereignissen zuordnen
und Anschließend die Folge der Änderungen der Datenbank abarbeiten.

\section{Funktionale Komponenten}

Diese Sektion beschreibt die einzelnen Komponenten welche mit der watches\_for primitive kombiniert werden. Sie bilden die Grundsteine des Prototypen.

In der ersten Komponente wird dabei die watches\_for Primitive genauer vorgestellt, und ein Code-Beispiel gegeben

\subsection{Auftragsannahme}

Die Umsetzung der Auftragsannahme wurde stark Vereinfacht.
Im Prototypen werden Aufträge mittels des put Skriptes in die Datenbank eingegeben.
Ein Beispiel wäre \Cref{fig:auftrag-beispieldaten}.
\begin{figure}
\begin{minted}{yaml}
project: "print-some"
type: juggler:order
status: received
axis:
  first: [1,2,3]
  second: [3,4,5]
  third: [1,2,3]
  fouth: [3,4,5]
\end{minted}
\caption{Beispiel Auftrage im YAML Format}
\label{fig:auftrag-beispieldaten}
\end{figure}

Es bringt einen Auftrag zum Ausdruck, welcher 4 Achsen der Konfiguration definiert.
Mit den Werten für diese Achsen, werden somit $3*3*3*3 = 81$ Arbeitspakete benötigt.
Das zugehörige Projekt ist offensichtlich. Das Feld ``type"" gibt den für CouchDB benötigten Dokumenttyp an (es stellt nur eine Konvention dar).
Der Status received sorgt dafür, das dieser Auftrag sofort in Bearbeitung geht

\FloatBarrier
Die Auftragsannahme beginnt dabei mit einem Auftrag der in den Zustand \textit{erhalten} (received) versetzt wurde.

Dieser sollte nun eigentlich Validiert werden und anschließend in einen der zustaende Valide oder Invalide versetzt werden.

Da diese Umsetzung recht einfach ist, soll sie als Beispiel dienen
\begin{figure}[h]
\mintedfromtexofcode{auftrag-validate}{juggler/handlers/inbox.py:order_validate}
\caption{Quelltext Ausschnitt Auftrag Validation}
\label{fig:auftrag-validation-code}
\end{figure}

Die Dekoration \cite{python:decorator}
der Funktion mit der watches\_for Primitive legt den zu Bearbeitenden Datentyp und Zustand fest.

Die Parameter der Funktion sind dabei zum einen die Datenbankverbindung (db)
Zum anderen das Objekt was Erwartet oder Übergeben wurde.
Der Ablauf ist nun denkbar einfach, der Status wird auf valide gesetzt und das Resultat wird wieder in der Datenbank gespeichert.
Damit ist der Eingang abgeschlossen.

\FloatBarrier
\subsection{Auftragsverwaltung}

\begin{verbatim}
- erstellen von tasks
- erstellen von schritten
- bekanntmachung
\end{verbatim}

\subsection{auftragsvergabe}

\begin{verbatim}
- mvcc<> claim objekte
- anerkennung durch den master

\end{verbatim}

\subsection{Auftragsabarbeitung}
\begin{verbatim}
-lineares modell, ein schritt nach dem anderen
\end{verbatim}

\subsection{Prozessschritte}

\begin{verbatim}
- intro prozesse unix
- ausfuehrung
- datensammlung
- theoretische betrachtung stats
- \ldots
\end{verbatim}

\subsection{Quellcode Management Schritte}


\begin{verbatim}
- anyvc
- exemplarischer ablauf
    - checkout
    - update
\end{verbatim}

\section{Exemplarische Erweiterung - Datenaggregation}

 
%XXX: falscher platz
\begin{verbatim}

- beispiel sommer
  - ausgabe eines programms
  - zusammenfassung in graphen/uebersichten

\end{verbatim}

