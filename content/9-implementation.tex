\chapter{Implementation ( 15 \% ) }


\section{Werkzeuge}
\subsection{Datenbank}

Das Kriterium der \textbf{Master-Master Replikation}
schränkte die Auswahl der verwendbaren Datenbanksysteme bereits stark ein.

In die nähere Betrachtung kommen CouchDB (dokumentorientiert)
und PostgreSQL (relational).
Beide Systeme besitzen Werkzeuge f\"ur Master-Master Replikation
und primitiven für Notifikationen.

%XXX: cites
Andere Systeme wie Mysql (relational), Mongodb(dokumentorientiert)
und  Neo4J (graph) scheiden aus, weil zu ihrem Funktionsumfang
nur die Master-Slave Replikation geh\"ort.
Das System Riak wurde verworfen, da es \"Anderungs-notifikationen
nicht unterstützte und in einem kurzen Vergleich
die Anfragen langsamer beantwortete.

Im Kurzvergleich von PostgreSQL mit CouchDB,
ging CouchDB als  hervor.
Im Test mussten bei Couchdb zwar Abstriche im Bereich Performance gemacht werden,
jedoch stellte sich heraus, das die \"Anderungsnotifikationen von Couchdb detaillierter sind.
Außerdem erscheint der Prozess der Replikation in CouchDB
als fehlertoleranter und einfacher.

% \cite
W\"ahrend in PostgreSQL die Mitteilungen einfach nur eine Nachricht sind,
welche mitteilt, dass etwas geändert wurde (aber nicht was)
% \cite couchdb:changestream}
so beinhalten die Mitteilungen von CouchDB, genaue Informationen
\"uber das ge\"anderte Objekt, eventuelle Datenbankkonflikte
und auf Wunsch sogar das Objekt selbst.

%XXX: more
 
\subsection{Programmiersprachen}

Es wurden 2 Programmiersprachen Ausgew\"ahlt.
Zum einen Python, wegen seiner Bibliotheken und
zum anderen Javascript, da es die Datenbankinterne Sprache von Couchdb ist.

\begin{table}[ht]
\centering
\begin{tabular}{l|c|c}
                            & \textbf{Python} & \textbf{Javascript} \\
    \hline
    Datenbankintern         & nein            & ja \\
    Prozesskontrolle        & integriert      & extern, rudimentär \\
    SCM Api                 & verfügbar       & nicht verfügbar \\
    CouchDB Client          & verfügbar       & verfügbar \\
\end{tabular}
\caption{Überblick über Features und Bibliotheken der Sprachen}
\label{tab:python-vs-js}
\end{table}

Ein besonderes Problem mit Javascript ist,
dass es Datenbankintern Bibliotheken, die Datenbank-extern sind,
nicht oder nur in limitierter Form verwenden kann.
Die Laufzeitumgebung weißt große Unterschiede
zwischen Datenbank-interner und Datenbank-externer Verwendung auf.

Weiterhin konnten wie in Tabelle~\ref{tab:python-vs-js} aufgezeigt,
für einige benötigte Bibliotheken keine
oder nur unzureichende Implementationen gefunden werden.
Somit ist Javascript für die Implementation der Komponenten
nur sehr bedingt geeignet.

Python hingegen hat Bibliotheken für alle notwendigen Grundfunktionen
und hat somit alle Voraussetzungen,
um die Implementation der Komponenten zu stützen.

\subsection{Bibliotheken}

Diese Sektion stellt die genutzten Bibliotheken vor.

\subsubsection{Datenbank Interaktion}

Zur Interaktion mit CouchDB wurde die Bibliothek ``couchdbkit"" \cite{couchdbkit:website} verwendet.
Sie stellte als einzige alle Funktionen der HTTP-Api von CouchDB zur Verfügung.
%XXX cites?
Andere Bibliotheken sind python-couchdb (kein Support fuer Änderungsmitteilungen)
und Paisley (sehr Unvollständig)

\subsubsection{SCM Interaktion}

Für die Interaktion mit der Versions-Kontrolle wurde die Bibliothek anyvc \cite{anyvc:website} verwendet.
Sie ist eine von 2 Python Bibliotheken für den Zugriff auf SCM,
und als einzige in der Lage mit einem Arbeitsverzeichniss zu interagieren.

\subsection{Weitere Werkzeuge}

\subsubsection{Testwerkzeuge}

Zum Testen wird das Test Framework py.test \cite{pytest:website} verwendet.
Es das einzige Test Framework für Python,
welches neben Werkzeugen für UnitTests auch Tools für
Funktionale und Akzeptanz Tests mitbringt.

Mit der Erweiterung ``pytest-couchdbkit"" \cite{pytest:couchdbkit} ist es Bereits
bestens für das Testen von Applikationen und einzelnen Funktionen,
welche CouchDB verwenden, geeignet.
Außerdem basiert ``pytest-couchdbkit"" auch auf der Bibliothek ``couchdbkit"",
und ist damit Bestens geeignet um die Basis für den Testprozess zu bilden.

\subsubsection{Datenbank Management}

Zum Management der Datenbank an sich wurde die integrierte Administrationsschnittstelle Futon verwendet \cite{couchdb:futon}.
Sie bietet einfache Schnittstellen für die Verwaltung von Datenbanken sowie der Replikation.

Um Datenbankinterne Programme zu verwalten,
wurde das Werkzeug ``couchdb-compose"" \cite{couchdb:compose} geschaffen.
Die Umsetzung dieses Werkzeugs ist nicht als Teil dieser Arbeit zu betrachten.
Notwendig wurde es, da existierenden Werkzeugen wie ``Kanso"" und ``couchapp""
keine Möglichkeit boten, um direkte Kontrolle über den Aufbau und die Struktur 
einer CouchDB Applikation zu üben.

\subsubsection{Javascript Bibliotheken}

Um einige wiederkehrende Aufgaben in Javascript zu vereinfachen,
wurde die Bibliothek underscore verwendet. \cite{javascript:underscore}.
Sie bietet diverse funktionale Werkzeuge um das schreiben
von Datenbank-internen Filtern und Views zu erleichtern


\section{Projektstruktur}
\subsection{Überblick}

Die Grundlegende Projekt-struktur beinhaltet einige Hauptverzeichnisse.
Der Codename des Projektes ist dabei ``Juggler''.


\begin{description}
    \item[bin] beinhaltet die Skripts um einzelne Komponenten zu starten
    \item[tool] beinhaltet Werkzeuge um mit der Datenbank des Prototyp zu interagieren
    \item[juggler] beinhaltet die Implementation der Komponenten in Python
    \item[composeapp] beinhaltet die couchdb-compose Applikation
    \item[testing] beinhaltet die automatischen Tests
    \item[example\_data] beinhaltet Beispiel-Datensätze im YAML Format
\end{description}

\subsection{Scripte und Werkzeuge}
Die Scripte und werkzeuge haben verschiedene Aufgaben und Aufruf-formen,
diese werden hier beschrieben dabei werden Parameter in eckigen Klammern angegeben.
Der Parameter namens \textbf{db} gibt dabei entweder einen kompletten Namen einer  Datenbank an oder den Namen einer lokalen Datenbank.

\begin{description}
    \item[bin/slave.py] [db] [name] simple \hfill \\
        Started einen Slave/Worker Prozess
    \item[bin/master.py] [db] \hfill \\
        Startet den Master Prozess - es darf nur einen geben und das System testet nicht, ob bereits einer aktiv ist.
    \item[tool/put.py] [db] [item] / [db] [item] --newid \hfill \\
        Überträgt den Inhalt der Datei namens \textit{item} zur Datenbank,
        ist das flag \textit{--newid} gesetzt, so wird eine neue Objekt ID erzwungen
    \item[tool/example-reset-db.sh] \hfill \\
        Shell Skript, um die Datenbank für die manuellen Tests vorzubereiten.
        Es verwendet immer die lokale Datenbank namens ``juggler''
    \item[tool/clean\_standing.py] [db]\hfill \\
        Setzt unterbrochene Arbeitspakete auf den Ursprungs-zustand zurück.
        Dies ist notwendig, da der Prototyp den Status interrupted für ein Arbeitspaket nicht unterstützt.
\end{description}

\subsection{Python Implementation}

Die Python Implementation besteht aus einigen wichtigen Dateien im Ordner namesn juggler.

Einsprungpunkte sind die Dateien ``simple\_master.py' und ``simple\_slave.py''.
Sie beinhalten die Implementationen der Management und Arbeiter Komponenten.

Hinzu kommt die Datei ``service.py'', welche das Grundgerüst für Komponenten enthält.

Folgende Verzeichnisse sind noch wichtig.

\begin{description}
    \dhitem[model] 
        enthält  die Modelklassen,
        welche die Daten aus der Datenbank auf Python Objekte abbilden
    \dhitem[handler] 
        enthält die Einzelteile der Komponenten,
        welche in Kommunikation mit der Datenbank stehen
    \dhitem[process]
        enthält die Implementation der Arbeitsschritte
        und ihrer Ausführungssumgebung
\end{description}

\subsection{CouchDB Applikation}



\section{Grundlegende Primitiven}
\subsection{Datenbank Indexe}

Die Indexe werden in CouchDB mittels 
eines MapReduce \cite{couchdb:views} Algorithmus umgesetzt,
welcher die Resultate innerhalb der Datenbank speichert.

\begin{description}
    \dhitem[tasks\_of]
        Der ``tasks\_of'' View hat 2 Aufgaben.
        In der Map Phase, erzeugt er eine \hbox{Key zu Value(status), Id} Zuordnung.
        Dabei ist der \textbf{Key} die Id des Auftrages,
        \textbf{Id} ist die Id des Arbeitspaketes
        und \textbf{Value} der Zustand dieses Arbeitspaketes.
        Dies ermöglicht es, einfach herauszufinden
        welche Arbeitspakete zu welchem Auftrag gehören.
        In der Reduce Phase wird schließlich das Set
        der Zustände der Arbeitspakete gebildet,
        besteht dieses ausschließlich aus finalen Zuständen,
        so kann der Auftrag als Abgeschlossen angesehen werden.
    \dhitem[steps\_of]
        Der ``steps\_of'' View hat lediglich die Aufgabe,
        eine Zuordnung von Arbeitsschritten
        zu ihren Arbeitspaketen zu schaffen.
    \dhitem[streams]
        Aufgabe dieses Views ist es,
        festzustellen, welche Datenströme (stdout, stderr)
        eines Arbeitsschritts Daten halten.
    \dhitem[lines]
        Der ``lines'' View dient dem Auffinden der einzelnen Zeilen
        eines Datenstroms. Sie werden nach der Zeilennummer geordnet.
    \dhitem[stm]
        Der ``stm'' view hat mehrere Aufgaben.
        Er dient der Statistischen Analyse und
        erzeugt seine Schlüssel aus der Kombination
        von Typ und Zustand eines Dokumentes.
        Dies ermöglicht es jederzeit festzustellen,
        welche Objekte sich in welchem Zustand befinden.
        In der Reduce Phase wird die Anzahl ermittelt.
        Somit lässt sich jederzeit feststellen,
        welche zustandsbehafteten Dokumente
        sich in welchem Zustand befinden.
%XXX: statret nach testing/eval
\end{description}

\subsection{watches\_for - Kontext für Komponenten}


\subsection{listen\_changes}

Die Primitive ``listen\_changes'' dient dazu,
Dient dazu, 

\subsection{run\_callbacks}

\subsection{watch\_for}

\section{Komponenten}

\subsection{Auftragsannahme}

\begin{verbatim}
- http hook, db auth erwähnen

- schritte
  - neu
  - bearbeiten
  - erhalten
  - validation
  - valid/invalid
  - bereitschaft
\end{verbatim}

\subsection{Auftragsverwaltung}

\begin{verbatim}
- erstellen von tasks
- erstellen von schritten
- bekanntmachung
\end{verbatim}

\subsection{auftragsvergabe}

\begin{verbatim}
- mvcc<> claim objekte
- anerkennung durch den master

\end{verbatim}

\subsection{Auftragsabarbeitung}
\begin{verbatim}
-lineares modell, ein schritt nach dem anderen
\end{verbatim}

\subsection{Prozessschritte}

\begin{verbatim}
- intro prozesse unix
- ausfuehrung
- datensammlung
- theoretische betrachtung stats
- \ldots
\end{verbatim}

\subsection{Quellcode Management Schritte}


\begin{verbatim}
- anyvc
- exemplarischer ablauf
    - checkout
    - update
\end{verbatim}

\section{Exemplarische Erweiterung - Datenaggregation}

 
%XXX: falscher platz
\begin{verbatim}

- beispiel sommer
  - ausgabe eines programms
  - zusammenfassung in graphen/uebersichten

\end{verbatim}

