\chapter{Analyse \& Design ( 25 \%)}
\label{chap:design}

\section{Grundlegende Systemarchitektur}


\begin{figure}[ht] 
  \centering
  \label{fig:grob-layout-komponenten}
  \includegraphics[width=\textwidth]{imageinput/grob-layout-komponenten.png}
  \caption{\"Ubersicht uber Systemkomponenten - physisch}
\end{figure}


\begin{figure}[ht]
  \centering
  \label{fig:grob-layout-komponenten-logisch}
  \includegraphics[width=\textwidth]{imageinput/grob-layout-komponenten-logisch.png}
  \caption{\"Ubersicht ber Systemkomponenten - logisch}
\end{figure}


\section{Grundlegendes Datenschema}


\begin{figure}[ht] 
  \centering
  \label{fig:datenstrukturen}
  \includegraphics[width=\textwidth]{imageinput/datenstrukturen-step-templates.png}
  \caption{Grundlegende Datenstrukturen}
\end{figure}




\section{Grundlegende Logik der Komponenten} %XXX: bettern na

% below here - unterordnen logik`

\subsection{Vorbereitende Primitiven}

\subsubsection{listen\_changes}
\subsubsection{watch\_for}
\subsubsection{gather\_next}
\subsubsection{run\_callbacks}


\subsection{Auftragsannahme}


\begin{figure}[ht]
  \centering
  \label{fig:lebenszyklus-auftrag-eingang}
  \includegraphics[height=5in]{imageinput/lebenszyklus-auftrag-eingang.png}
  \caption{Auftragsannahme: Flowgraph}
\end{figure}

- 2 teile
- eingang \& validation


\subsubsection{Eingang}

\begin{verbatim}
- quellen
- editiern
- typisches
\end{verbatim}

\subsubsection{Validation}
\begin{verbatim}
- notwendig weil ...
- beispiele fuer checks
- theoretisch
\end{verbatim}


\subsection{Management}

\begin{figure}[ht] 
  \centering
  \label{fig:lebenszyklus-auftrag-abarbeitung}
  \includegraphics[height=4in]{imageinput/lebenszyklus-auftrag-abarbeitung.png}
  \caption{Auftragsannahme: Flowgraph}
\end{figure}

\subsubsection{Auftragsvorbereitung}

\begin{verbatim}
- 
\end{verbatim}


\subsubsection{Bereitstellung von Arbeitspacketen}
\subsubsection{Abschluss von Auftr\"agen}


\subsection{Zuteilung/Abarbeitung von Arbeitspacketen}


\subsubsection{Lebenszyklus eines Arbeitspacketes}


\begin{figure}[ht] 
  \centering
  \label{fig:lebenszyklus-arbeitspaket}
  \includegraphics[height=4in]{imageinput/lebenszyklus-arbeitspaket.png}
  \caption{Lebenszyklus eines Arbeitspacketes bei Ausschreibungen}
\end{figure}


\subsubsection{Vorbereitung Abarbeitung}

\subsection{\"Uberblick Zuteilungsmethoden}


\begin{verbatim}
- diese sektion besch. sich mit


- methoden
    - token basiert
    - ausschreibungsbasiert

\end{verbatim}


\subsubsection{token basierte zuweisung}

\begin{verbatim}
- arbeiter teilen nur mit, dass sie arbeitsfaehig sind
- manager kontrolliert wer welchen auftrag erhaelt
cons:
    - fuer erweiterte use-cases extra wissen im manager notwendig
\end{verbatim}

\begin{figure}[ht] 
  \label{fig:auftrag-zuteilung-token}
  \begin{sequencediagram}
      \newinst{worker}{:Worker}
      \newinst[1]{manager}{:Manager}
      \mess{worker}{token <spec>}{manager}
      \mess{manager}{work <spec>}{worker}
      \mess{worker}{result}{manager}
  \end{sequencediagram}
  \caption{Auftragszuteilung: Tokenbasiert}
\end{figure}

\subsubsection{ausschreibungsbasierte zuweisung}

\begin{verbatim}
- manager teilt offene auftraegeposten mit (in datenbank verf.)
- arbeiter konkurieren um offene auftraege
- manager entscheidet wer den aufrag dann erhaelt


- autonomere arbeiter
- manager muss nur noch entscheiden wer, nicht mehr warum
- aufgrund der datenbank konzeptuell einfacher -> beweis oder weg
\end{verbatim}

\begin{figure}[ht] 
  \label{fig:auftrag-zuteilung-claim}
  \begin{sequencediagram}
      \newinst{workera}{:Worker A}
      \newinst[1]{manager}{:Manager}
      \newinst[1]{workerb}{:Worker B}
      \mess[1]{manager}{availiable}{workera}
      \prelevel
      \prelevel
      \mess[1]{manager}{availiable}{workerb}

      \mess[1]{workera}{claim}{manager}
      \prelevel
      \prelevel
      \mess[2]{workerb}{claim}{manager}
      %XXX: better call?
      %\prelevel
      %\prelevel
      %\begin{call}{manager}{approve}{manager}{workera}
      %\end{call}
      \mess{manager}{approve A}{workera}
      \prelevel
      \mess{manager}{approve A}{workerb}
  \end{sequencediagram}
  \caption{Auftragszuteilung: Ausschreibungsbasiert}
\end{figure}


\subsubsection{Abschluss Abarbeitung}

- ende der arbeisschritte
- zusammenfassung resultat
- endscheidung fehlschlag oder nucht


\subsection{Abarbeitung von Arbeitspacketen}

\begin{verbatim}
- lineare abarbeitung
- abbrich bei fehlschlag
\end{verbatim}

\subsubsection{Arbeitsschritte}


\begin{figure}[ht] 
  \centering
  \label{fig:lebenszyklus-arbeitsschritt}
  \includegraphics[height=3.4in]{imageinput/lebenszyklus-arbeitsschritt.png}
  \caption{Stategraph eines Arbeitschrittes}
\end{figure}

\begin{verbatim}
- kill wird in der impl nicht betrachtet

\end{verbatim}


\subsubsection{Datensammlung zur Laufzeit}

\begin{verbatim}
- sinn/echtzeit?

- beispielhaft
    - STDOUT/ERR
    - exakte testresultate/reports
\end{verbatim}

\subsubsection{Datensammling nach Abschluss eines Schrittes}

- junitxml
- logfiles

- betrachtung extra schritt vs interne funktion

\subsubsection{Abschluss von Arbeitschritten}

- returncodes
- fehler

\subsection{Arten von Arbeitschritten}

\subsubsection{\"Ubersicht}

\begin{figure}[h!]
  \centering
  \label{fig:klassen-arten-arbeitsschritt}
  \includegraphics[height=3.5in]{imageinput/klassen-arten-arbeitsschritt.png}
  \caption{Arten von Arbeitschritten}
\end{figure}


\FloatBarrier
\subsubsection{Prozessaktionen}

- was/wozu
- datensammlung laufzeit
- datensammlung ende

\subsubsection{Quellcode Management Aktionen}

- ablauf, beispiele



\section{Besondere Ans\"atze zur Datenbankinteraktion}

%XXX: http://dbmsmusings.blogspot.de/2010/04/problems-with-cap-and-yahoos-little.html


\subsection{CAP Abdeckung}

Wie bereits in Sektion~\ref{sec:base:cap} erw\"ahnt,
ist es immer nur m\"oglich 2 der 3 Aspekte des CAP Theorems abzudecken.

Jedoch ist es durchaus legitim f\"ur verschiedene Teile einer Applikation unterschiedliche Bereiche abzudecken.
Sobald genau definiert ist, f\"ur welche Daten in welchem Kontext welche Eigenschafen benoetigt werden,
kann ein konsistentes Modell geschaffen werden.

Wichtig ist bei dieser Betrachtung, dass die Unterschiedlichen des Entwickelten CI-Systemes
nicht zwingend eine direkte Konsistenzbindung untereinander ben\"otigen.
Wichtig ist nur, die Konsistenz zwischen einer Komponente und dem Datenbankknoten,
mit dem sie Kommuniziert.

Das Hauptsystem, in dem alle Komponenten in Kommunikation stehen,
%XXX: s1?
soll nach Systemanforderung \textbf{S1} immer verf\"ugbar sein, und Teilausf\"alle verkraften.
Somit kommt f\"ur die Kommunikation zwischen Komponenten nur das Model \textbf{A-P} in Frage
(was Verf\"ugbar und Partitionstollerant bedeutet).

Die Anbinding einzelner Komponenten and ihre Datenbankknoten, hat jedoch andere Anforderungen.
Da eie direkte Anbindung and die Datenbank f\"ur das Funktionieren einer Komponente unabdingbar ist,
kann in diesem Fall nur das Modell \textbf{C-A} zum Einsatz kommen.


%XXX: http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed


\subsection{Statusmaschienen zur Konsistenzwahrung}

%XXX: Literatur
% http://blog.incubaid.com/2012/10/25/caulking-your-distributed-algorithm-implementation/

Statusmaschienen sind ein allgemein bekanntes Werkzeug,
um den den Ablauf eines komplexen Programmes zu beschreiben oder zu erkl\"aren.
In der Regel wird dazu ein sog. StatusGraph verwendet.
Dieser ist ein Gerichteter Graph der die Zust\"ande und Zustands\"anderungen eines Systemes beschreibt.

Wie bereits in Abbildung \ref{fig:lebenszyklus-arbeitspaket} gezeigt,
stellt der Lebenszyklus eines Arbeitspacketes einen solchen Statusgraph dar.
Als Besonderheit ist er sogar frei von Zyklen.
Dadurch ist es unm\"oglich den gleichen Status noch einmal zu erreichen.

Bindet man Zus\"atzlich noch die Transitionen an bearbeitende Knoten (Agenten ausserhalb der Datenbank),
so ist es auch bei einer Partitionierung der Datenbank eine Konsistenz der Gesammtsystemes gew\"ahrleistet.

%XXX: moar?


Mit dem dem Eingang und der Abarbeitung von Auftr\"agen verh\"alt es sich \"ahnlich,
jedoch ist der Graph dort Wesentlich einfacher.
Die Abbildungen \ref{fig:lebenszyklus-auftrag-eingang} und \ref{fig:lebenszyklus-auftrag-abarbeitung} zeigen den groben Ablauf.
Der Wechselpunkt zwischen Eingang und Abarbeitung ist die der Validation angeschlossene Markierung zur Bereitschaft.
Da es nur diesen einen Punkt des Austausches gibt, ist die Konsistenzwahrung des Auftrages Denkbar einfach,
Mit der Bereitschaft, wird die Verwantwortung vom Eingang zur Abarbeitung \"ubertragen.

\section{Logisches Gesammtkonzept}



\section{Benutzerinterface}

% kann krit
% kein tolles
% nur werkzeuge


\section{zusammenfassung}

was kommt
was kommt nicht
